service: my-blog-java
image: ghcr.io/jkwuc89/my_blog_java

# How long to wait for container to become ready (default 30s)
# Spring Boot needs extra time for Hibernate/Flyway initialization
# 90s gives 40s start-period + 50s for healthchecks to pass
deploy_timeout: 90

# Deploy to the same DigitalOcean droplet as Rails
servers:
  web:
    hosts:
      - 209.97.157.86
    proxy: false
    labels:
      # Path-based routing: /java goes to Java app, / goes to Rails app
      # Higher priority (10) ensures this rule is checked before Rails default rule
      traefik.http.routers.my-blog-java.rule: (Host(`jkwuc89.com`) || Host(`www.jkwuc89.com`)) && PathPrefix(`/java`)
      traefik.http.routers.my-blog-java.priority: 10
      traefik.http.routers.my-blog-java.entrypoints: websecure
      traefik.http.routers.my-blog-java.tls.certresolver: letsencrypt
      # Forward to Spring Boot on port 8080 (Spring Boot handles /java context path)
      traefik.http.services.my-blog-java.loadbalancer.server.port: 8080

# Proxy disabled for Java app - using Traefik directly for path-based routing
# Rails app uses kamal-proxy for host-based routing, Java uses Traefik labels

# Where you keep your container images (same registry as Rails)
registry:
  server: ghcr.io
  username: jkwuc89
  password:
    - KAMAL_REGISTRY_PASSWORD

# Environment Variables
env:
  clear:
    # Set Spring Boot context path to /java
    SERVER_SERVLET_CONTEXT_PATH: /java
    # Database path inside container
    SPRING_DATASOURCE_URL: "jdbc:sqlite:/app/storage/java_production.sqlite3"

# Aliases for common operations
aliases:
  shell: app exec --interactive --reuse "bash"
  logs: app logs -f
  dbc: app exec --interactive --reuse "sqlite3 /app/storage/java_production.sqlite3"

# CRITICAL: Persist SQLite Database (separate from Rails)
# This maps a folder on the Droplet to the storage folder in the container.
volumes:
  - "/var/lib/my-blog-java-storage:/app/storage"

# Configure the image builder.
builder:
  arch: amd64
